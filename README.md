# Домашнее задание по лекции "Кеширование Redis/memcached" - Фомичев Анатолий

## Ссылка на дз - https://github.com/netology-code/sdb-homeworks/blob/main/11-02.md

### Задание 1
` Кеширование с использованием Redis или Memcached может решить проблемы, связанные с производительностью и масштабируемостью приложений. 
Уменьшение нагрузки на базу данных и ускорение доступа к данным.
Снижение времени отклика и повышение доступности.
Обработка пиковых нагрузок и оптимизация сложных запросов.
Кеширование статических ресурсов и результатов API.`

### Задание 1.2

![alt text](https://github.com/SLzDevOps/netology-education-hw81/blob/main/Screenshot_474.png)
![alt text](https://github.com/SLzDevOps/netology-education-hw81/blob/main/Screenshot_474.png)
![alt text](https://github.com/SLzDevOps/netology-education-hw81/blob/main/Screenshot_474.png)







` Для лендингов и CRM Ключевые требования — скорость записи и гибкость, для этой задачи хорошо подойдет NoSQL база данных типа документно-ориентированной или ключ-значение. MongoDB позволяет динамически изменять схему документа, поддерживает горизонтальное масштабирование и обеспечивает быстрый доступ к данным. Redis отлично подходит для кеширования часто запрашиваемых данных, что ускорит работу сайта и приложения.`


`  Выбор: документно-ориентированная NoSQL СУБД. `

### Задание 1.3
` В задании требуется простая структура для хранения инструкций, регламентов и обучающих материалов, которую легко поддерживать и обновлять, для этих целей лучше подойдет NoSQL база данных типа документно-ориентированной. Пример: MongoDB - она удобна для хранения большого количества слабо структурированных документов.`


` Выбор: документно-ориентированная NoSQL СУБД.`

### Задание 1.4
` Задача маршрутизации — это задача с построением графов путей и зависимостей: найти оптимальный путь между точками (узлами) по дорогам (ребрам) с учетом весов (время, расстояние). Лучшим выбором будут специализированные графовые СУБД, которые могут быстро находить кратчайшие пути, соседние объекты и анализировать сложные связи.`


` Выбор: графовые СУБД.`

---


### Задание 2

` Это транзакция, которая соответствует принципам ACID:`

`	- Начало транзакции: система фиксирует начало операции, все последующие шаги будут частью одной атомарной операции. На этом этапе устанавливается блокировка на запись для строки с балансом пользователя в базе данных(для предотвращения одновременного использования).`

`	- Списание средств с источника платежа: система взаимодействует с платежным шлюзом для списания указанной суммы со чета пользователя. Получение от шлюза подтверждения об успешном списании (авторизации платежа).`

`	- Зачисление средств на целевой счёт: после успешного списания система увеличивает значение баланса телефона в базе данных системы патежей на сумму пополнения.`

`	- Фиксация транзакции в системе платежей: Система подтверждает, что все предыдущие шаги внутри транзакции прошли успешно, вносит изменения в основную базу данных окончательно. После этого шага баланс пользователя обновляется и становится доступным для использования. Блокировки снимаются.`

`	- Оповещение оператора мобильной связи: платёжная система уведомляет оператора связи о совершённом пополнении, передавая соответствующую информацию для последующего зачисления денег на счёт абонента.`

`	- Завершение транзакции: Пользователю отправляется уведомление об успешном пополнении, сохраняется история операции в личном кабинете, обновляются балансы в системе.`


`Эти шаги гарантируют атомарность транзакции и согласованность базы данных.`

---


### Задание 3

` Пять преимуществ SQL-систем по отношению к NoSQL:`

`	- Строгая схема данных SQL используют жёстко определённую схему данных, что упрощает управление большими объёмами данных и помогает предотвратить дублирование и несогласованность информации.Это заставляет тщательно продумывать модель данных, что служит встроенной защитой от ошибок.`

`	- Высокая надежность и согласованность данных (ACID). Транзакционные свойства ACID (атомарность, консистентность, изолированность, долговечность) делают SQL-системы надёжными для критически важных приложений. Это означает, что каждая операция либо выполняется полностью, либо не выполняется вовсе. Данные всегда находятся в корректном состоянии.`

`	- Универсальность языка SLQ облегчает написание запросов, позволяет с помощью одного запроса выполнять сложные операции и повышает переносимость данных между различными платформами.`

`	- Язык запросов SQL существует десятилетиями, рынок программного обеспечения СУБД насыщен множеством проверенных временем продуктов (MySQL, PostgreSQL, Oracle, Microsoft SQL Server), которые предлагают зрелую экосистему, инструменты разработки и администрирования, обширную документацию. Уровень надежности и предсказуемости SQL-систем несколько выше, по отношению к NoSQL.`

`	- Реляционная модель и язык SQL идеально подходят для сложных запросов, требующих агрегации и соединений. Возможность написания сложных запросов с использованием JOIN'ов, агрегативных функций и индексов позволяет эффективно решать аналитические задачи и извлекать информацию из данных.`

---


### Задание 4

`Основные критерии выбора СУБД:`

`	- Масштабируемость — способность системы эффективно работать на 1000 узлах.`

`	- Производительность вычислений — скорость обработки данных и выполнения запросов.`

`	- Отказоустойчивость — надежность при работе с большим кластером.`

`	- Параллельная обработка — эффективность распределения нагрузки.`

`	- Управление данными — механизмы репликации и синхронизации.`


`Реляционные СУБД (PostgreSQL, MySQL) сразу отпадают, так как они не предназначены для горизонтального масштабирования на 1000 узлов.`
`Мой выбор: `

`	- MPP-системы с архитектурой "shared-nothing", где каждая машина в кластере работает со своей частью данных независимо и имеет свои собственные процессор и память. Запрос разбивается на множество подзапросов, которые выполняются на всех узлах параллельно, а результаты агрегируются.`

`	Примеры: ClickHouse, Apache Druid, Greenplum, Amazon Redshift.`


`или`


`	- MapReduce — о модель распределенных вычислений, которая параллельно обрабатывает большие объемы данных, разделяя процессы вычисления между множеством серверов. Две фазы:`

`	* Map: Каждая машина обрабатывает свой "кусок" данных и выдает промежуточный результат.`

`	* Reduce: Другие машины берут эти промежуточные результаты, группируют и агрегируют их в финальный ответ.`


`	Примеры: Apache Spark, Apache Flink, Apache Ignite.`

![alt text](https://github.com/SLzDevOps/netology-education-hw81/blob/main/Screenshot_474.png)
![alt text](https://github.com/SLzDevOps/netology-education-hw81/blob/main/Screenshot_474.png)
![alt text](https://github.com/SLzDevOps/netology-education-hw81/blob/main/Screenshot_474.png)
![alt text](https://github.com/SLzDevOps/netology-education-hw81/blob/main/Screenshot_474.png)
